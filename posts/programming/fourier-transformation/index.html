<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Noah Peeters"><meta property="og:url" content="https://noahpeeters.de/posts/programming/fourier-transformation/"><meta property="og:title" content="Simple discrete fourier transformation in Swift"><meta property="og:site_name" content="Noah Peeters"><meta name=description content="I implemented a simple but inefficient discrete fourier transformation in Swift. Mostly for learning purposes."><meta property="og:description" content="I implemented a simple but inefficient discrete fourier transformation in Swift. Mostly for learning purposes."><meta name=twitter:description content="I implemented a simple but inefficient discrete fourier transformation in Swift. Mostly for learning purposes."><meta name=twitter:card content="summary"><meta name=twitter:title content="Simple discrete fourier transformation in Swift"><meta name=twitter:creator content="Noah Peeters"><title>Simple discrete fourier transformation in Swift</title><link rel=stylesheet href=/main.min.css><script src=/main.js></script>
<script data-goatcounter=https://noahpeeters.goatcounter.com/count async src=//gc.zgo.at/count.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css integrity=sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js integrity=sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><article><header><p class=breadcrumbs><span><a href=https://noahpeeters.de/ class=capitalize>Noah Peeters</a> /
<span><a href=https://noahpeeters.de/posts/ class=capitalize>Blog</a> /
<span><span>Simple discrete fourier transformation in Swift</span></span></p><h1>Simple discrete fourier transformation in Swift</h1><div class=article__meta>15.11.2022</div><div class=article__meta><a href=/posts/programming/fourier-transformation/DFT.playground.zip title=Download class="button button__micro" data-color=default data-variant=contained target=_blank rel=noreferrer>[Download]</a></div></header><p><a href=https://en.wikipedia.org/wiki/Fourier_transform>Fourier transformation</a> is a mathematical operation that can be used to decompose a signal into its frequency components. It is used in many fields, for example in signal processing, image processing, and in physics. It is also used in cryptography, for example in the RSA algorithm.</p><p>Discrete Fourier transformation (DFT) is a special case of the Fourier transformation. It is used to decompose a signal that is sampled at discrete points in time. When using digital singnals on computers, this is always the case.</p><p>The theory behind fourier transfomation is that any signal can be expressed as a (potentially infinite) sum of sin and cos functions. For each of the frequency components, we want to fond the amplitude and the phase.</p><p>In this post, I will explain step by step how I implemented</p><p>To get started, I created a data structure to represent the different signal parts consisting of frequency, amplitude, and phase:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SignalPart</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> frequency: Double
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> amplitude: Double
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> phase: Double
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=generating-a-signal>Generating a signal</h2><p>The next step is to create a function to generate the signal. Becuase all of this only works for discrete signals, we need to sample the signal at discrete points in time. The sampling rate is the number of samples per second.
As we want to use the signal for testing, we need to be able to generate a signal with a known frequency. The function <code>generateDiscreteSignal</code> takes the sampling rate, the duration, and the signal parts as parameters. It returns an array of samples.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>generateDiscreteSignal</span>(numberOfSamplesPerSecond: Int, seconds: Double, signalParts: [SignalPart]) -&gt; [Double] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> numberOfSamples = Int(Double(numberOfSamplesPerSecond) <span style=color:#f92672>*</span> seconds)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#ae81ff>0.</span>.&lt;numberOfSamples)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate the timestamp for each sample</span>
</span></span><span style=display:flex><span>        .map { Double($0) <span style=color:#f92672>/</span> Double(numberOfSamples <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> Double(seconds) }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate the signals value fot each timestamp</span>
</span></span><span style=display:flex><span>        .map { (time: Double) -&gt; Double <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// To calculate the signal value, sum up the values of the different signal parts</span>
</span></span><span style=display:flex><span>            signalParts
</span></span><span style=display:flex><span>                .map { (signalPart: SignalPart) -&gt; Double <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                    sin((signalPart.frequency <span style=color:#f92672>*</span> time <span style=color:#f92672>+</span> signalPart.phase) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Double.pi) <span style=color:#f92672>*</span> signalPart.amplitude
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                .reduce(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>+</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, we can generate a signal with a known frequency. For example, we can generate a signal with a frequency of 1 Hz and an amplitude of 1 combined with a signal with a frequency of 5 Hz and an amplitude of 0.1 and a phase of 0.25 (shifted by <span class=jsonly>\(0.25 \cdot 2 \pi = 90^{\circ}\)</span><noscript><img style=display:inline;vertical-align:middle src=https://latex.codecogs.com/gif.latex?\inline&space;0.25%20%5ccdot%202%20%5cpi%20%3d%2090%5e%7b%5ccirc%7d title="0.25 \cdot 2 \pi = 90^{\circ}"></noscript>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> signal = generateDiscreteSignal(numberOfSamplesPerSecond: <span style=color:#ae81ff>50</span>, seconds: <span style=color:#ae81ff>1</span>, signalParts: [
</span></span><span style=display:flex><span>    SignalPart(frequency: <span style=color:#ae81ff>1</span>, amplitude: <span style=color:#ae81ff>1</span>, phase: <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    SignalPart(frequency: <span style=color:#ae81ff>5</span>, amplitude: <span style=color:#ae81ff>0.1</span>, phase: <span style=color:#ae81ff>0.25</span>)
</span></span><span style=display:flex><span>])
</span></span></code></pre></div><p>To check if this is working, we can use Swift Playgrounds build in function to plot signals. To make Swift Playgrounds numbers as a graph, the code must itterate over the values which can easily be accomplished using a simple <code>map</code>: <code>signal.map() { $0 }</code>. The result is the following graph:</p><figure><img src=/posts/programming/fourier-transformation/signal-graph.png alt="Graph of the generated signal" style=width:;height:><figcaption style=text-align:>Graph of the generated signal</figcaption></figure><p>As you can see, the signal consists of two parts with different frequencies. The first part has a frequency of 1 Hz and the second part has a frequency of 5 Hz. The second part is shifted by 90 degrees.</p><h2 id=discrete-fourier-transformation>Discrete Fourier transformation</h2><p>Now that we have a signal, we can use the discrete fourier transformation to decompose it into its frequency components. I don&rsquo;t want to go into the details of the fourier transformation here, as there are already very good explanations on the internet. For example, the video <a href="https://www.youtube.com/watch?v=nmgFG7PUHfo">The Algorithm That Transformed The World</a> from Veritasium is a very good visual explenation and was the inspiration for this post.</p><p>The base idea of the algorithm is to multiply the signal with many pure sine and cosine functions with only one frequency. If the signal contains a component of that frequency, the result is non-zero. If the signal does not contain the frequency, the result is zero. Using that knowledge, we can implement the algorithm. The issue with this algorithm is that it is very inefficient. It has a time complexity of <code>O(n^2)</code>. This means that it takes <code>n^2</code> time to calculate the transformation for a signal with <code>n</code> samples. If we already know that we only want to have a look at the first <code>k</code> frequency components, we can limit this in the algorithm to only calculate the first <code>k</code> frequency components. This will reduce the time complexity to <code>O(kn)</code>. In the follwing example, I set k to 15.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>discreteFourierTransform</span>(signal: [Double], durationInSeconds: Int) -&gt; [SignalPart] {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> baseFrequency = <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> Double(durationInSeconds)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// To calculate all possible frequencies, use the following</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// let frequencies = (0..&lt;signal.count)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> frequencies = (<span style=color:#ae81ff>0.</span>.&lt;<span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>        .map { Double($0) <span style=color:#f92672>*</span> baseFrequency }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> signalParts = frequencies.map { frequency <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> sinPart = signal.enumerated().map { index, value -&gt; Double <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> time = Double(index) <span style=color:#f92672>/</span> Double(signal.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> Double(durationInSeconds)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> value <span style=color:#f92672>*</span> sin(frequency <span style=color:#f92672>*</span> time <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Double.pi)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>            .reduce(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>+</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> cosPart = signal.enumerated().map { index, value -&gt; Double <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> time = Double(index) <span style=color:#f92672>/</span> Double(signal.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> Double(durationInSeconds)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> value <span style=color:#f92672>*</span> cos(frequency <span style=color:#f92672>*</span> time <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Double.pi)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>            .reduce(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>+</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Calculate combined sine wave</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> amplitude = sqrt(cosPart<span style=color:#f92672>*</span>cosPart<span style=color:#f92672>+</span>sinPart<span style=color:#f92672>*</span>sinPart)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> phase = atan2(cosPart, sinPart) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> Double.pi)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> SignalPart(frequency: frequency, amplitude: amplitude, phase: phase)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Normalize amplitude</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> signalParts.map {
</span></span><span style=display:flex><span>        SignalPart(frequency: $0.frequency, amplitude: $0.amplitude <span style=color:#f92672>/</span> Double(signal.count <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>, phase: $0.phase)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, we can use the function to calculate the frequency components of the signal we generated before:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>let</span> detectedFrequncies = discreteFourierTransform(signal: signal, durationInSeconds: <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>Using the same method as above, we can plot the amlitude of the frequency components:</p><figure><img src=/posts/programming/fourier-transformation/detected-amplitudes.png alt="Graph of the detected frequencies. A large spike at 1Hz and a small spike at 5Hz are visible." style=width:;height:><figcaption style=text-align:>Graph of the detected frequencies. A large spike at 1Hz and a small spike at 5Hz are visible.</figcaption></figure><p>As you can see, the algorithm detected the two frequencies we used to generate the signal with their respective amplitudes.</p></article><footer><hr><div class=legal_links><a href=/privacy>Privacy Policy</a>
<a href=/imprint>Imprint</a>
<a href=/digital-documents>Digital Documents</a></div>©2019 — 2022, Noah Peeters, All Rights Reserved</footer></body></html>